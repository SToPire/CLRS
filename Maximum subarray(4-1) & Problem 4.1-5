#include<iostream>
#include<vector>
#include<tuple>
using namespace std;
auto find_max_cross_subarry(vector<int>& v, int begin, int mid, int end)-> tuple<int,int,int>
{
	int lmax = v[mid], rmax = v[mid + 1];
	int sum = v[mid];
	int lindex = mid, rindex = mid + 1;
	for (int i = mid - 1 ; i >= begin; --i)
	{
		sum += v[i];
		if (sum > lmax) {
			lmax = sum;
			lindex = i;
		}
	}
	sum = v[mid + 1];
	for (int i = mid + 2; i <= end; ++i)
	{
		sum += v[i];
		if (sum > rmax) {
			rmax = sum;
			rindex = i;
		}
	}
	return { lindex,rindex,lmax + rmax };
}
auto find_max_subarray(vector<int>& v,int begin,int end) ->tuple<int,int,int>
{
	if (begin == end) return{ begin,end,v[begin] };
	int mid = (begin + end) / 2;
	auto lres = find_max_subarray(v, begin, mid);
	auto rres = find_max_subarray(v, mid + 1, end);
	auto crossres = find_max_cross_subarry(v, begin, mid, end);
	if (get<2>(lres) >= get<2>(rres) and get<2>(lres) >= get<2>(crossres)) return lres;
	else if (get<2>(rres) >= get<2>(lres) and get<2>(rres) >= get<2>(crossres)) return rres;
	else return crossres;
}
auto linearComplexity(vector<int>& v, int begin, int end) ->tuple<int, int, int> //思考题4.1-5
{
	int sum = 0, max = 0, lindex = 0, rindex = 0, temp = 0;
	for (int i = begin;i != end; ++i)
	{
		sum += v[i];
		if (sum > max) {         //仅当出现和更大的序列时，更新三个输出变量
			max = sum;
			lindex = temp;
			rindex = i;
		}
		else if (sum < 0) {      //如果sum<0,说明这一段序列不应该完整地位于最后结果序列中(1.因为结果序列排除掉这一段完整序列可以更大 2.这一段序列的一部分可能是最终结果)
			sum = 0;			 //重置sum,更新一个临时变量，代表新的序列的左端位置
			temp = i + 1;        //基于前述2.的原因，不能直接更新lindex
		}
	}
	return { lindex,rindex,max };
}
int main()
{
	vector<int> vi{ 13,-3,-25,20,-3,-16,-23,18,20,-7,12,-5,-22,15,-4,7 };
	auto res = find_max_subarray(vi, 0, vi.size() - 1);
	//auto res = linearComplexity(vi, 0, vi.size() - 1);
	cout << "Maximum subarray is:" << endl;
	for (int i = get<0>(res); i <= get<1>(res); ++i) cout << vi[i]<<' ';
	cout << endl << "with max sum of " << get<2>(res);
	system("pause");
}
